
using @absolute_import = @@__future__.absolute_import;

using @division = @@__future__.division;

using @print_function = @@__future__.print_function;

using @unicode_literals = @@__future__.unicode_literals;

using argparse;

using io;

using os;

using re;

using glob;

using subprocess;

using dedent = textwrap.dedent;

using Iterable = typing.Iterable;

using Text = typing.Text;

using System.Diagnostics;

using System.Collections.Generic;

public static class gen_proto {
    
    public static string autogen_header = @"\
//
// WARNING: This file is automatically generated!  Please edit onnx.in.proto.
//


";
    
    public static string LITE_OPTION = @"

// For using protobuf-lite
option optimize_for = LITE_RUNTIME;

";
    
    public static string DEFAULT_PACKAGE_NAME = "onnx";
    
    public static object IF_ONNX_ML_REGEX = re.compile(@"\s*//\s*#if\s+ONNX-ML\s*$");
    
    public static object ENDIF_ONNX_ML_REGEX = re.compile(@"\s*//\s*#endif\s*$");
    
    public static object ELSE_ONNX_ML_REGEX = re.compile(@"\s*//\s*#else\s*$");
    
    public static bool MYPY = false;
    
    public static List<List<object>> process_ifs(object lines, object onnx_ml) {
        // type: (Iterable[Text], bool) -> Iterable[Text]
        var in_if = 0;
        foreach (var line in lines) {
            if (IF_ONNX_ML_REGEX.match(line)) {
                Debug.Assert(0 == in_if);
                in_if = 1;
            } else if (ELSE_ONNX_ML_REGEX.match(line)) {
                Debug.Assert(1 == in_if);
                in_if = 2;
            } else if (ENDIF_ONNX_ML_REGEX.match(line)) {
                Debug.Assert(1 == in_if || 2 == in_if);
                in_if = 0;
            } else if (0 == in_if) {
                yield return line;
            } else if (1 == in_if && onnx_ml) {
                yield return line;
            } else if (2 == in_if && !onnx_ml) {
                yield return line;
            }
        }
    }
    
    public static object IMPORT_REGEX = re.compile(@"(\s*)import\s*""([^""]*)\.proto"";\s*$");
    
    public static object PACKAGE_NAME_REGEX = re.compile(@"\{PACKAGE_NAME\}");
    
    public static object ML_REGEX = re.compile(@"(.*)\-ml");
    
    public static object process_package_name(List<List<object>> lines, object package_name) {
        // type: (Iterable[Text], Text) -> Iterable[Text]
        var need_rename = package_name != DEFAULT_PACKAGE_NAME;
        foreach (var line in lines) {
            var m = need_rename ? IMPORT_REGEX.match(line) : null;
            if (m) {
                var include_name = m.group(2);
                var ml = ML_REGEX.match(include_name);
                if (ml) {
                    include_name = "{}_{}-ml".format(ml.group(1), package_name);
                } else {
                    include_name = "{}_{}".format(include_name, package_name);
                }
                yield return m.group(1) + "import \"{}.proto\";".format(include_name);
            } else {
                yield return PACKAGE_NAME_REGEX.sub(package_name, line);
            }
        }
    }
    
    public static object PROTO_SYNTAX_REGEX = re.compile(@"(\s*)syntax\s*=\s*""proto2""\s*;\s*$");
    
    public static object OPTIONAL_REGEX = re.compile(@"(\s*)optional\s(.*)$");
    
    public static object convert_to_proto3(object lines) {
        // type: (Iterable[Text]) -> Iterable[Text]
        foreach (var line in lines) {
            // Set the syntax specifier
            var m = PROTO_SYNTAX_REGEX.match(line);
            if (m) {
                yield return m.group(1) + "syntax = \"proto3\";";
                continue;
            }
            // Remove optional keywords
            m = OPTIONAL_REGEX.match(line);
            if (m) {
                yield return m.group(1) + m.group(2);
                continue;
            }
            // Rewrite import
            m = IMPORT_REGEX.match(line);
            if (m) {
                yield return m.group(1) + "import \"{}.proto3\";".format(m.group(2));
                continue;
            }
            yield return line;
        }
    }
    
    public static void gen_proto3_code(
        object protoc_path,
        string proto3_path,
        string include_path,
        string cpp_out,
        string python_out) {
        // type: (Text, Text, Text, Text, Text) -> None
        Console.WriteLine("Generate pb3 code using {}".format(protoc_path));
        var build_args = new List<string> {
            protoc_path,
            proto3_path,
            "-I",
            include_path
        };
        build_args.extend(new List<string> {
            "--cpp_out",
            cpp_out,
            "--python_out",
            python_out
        });
        subprocess.check_call(build_args);
    }
    
    public static string translate(object source, int proto, object onnx_ml, object package_name) {
        // type: (Text, int, bool, Text) -> Text
        var lines = source.splitlines();
        lines = process_ifs(lines, onnx_ml: onnx_ml);
        lines = process_package_name(lines, package_name: package_name);
        if (proto == 3) {
            lines = convert_to_proto3(lines);
        } else {
            Debug.Assert(proto == 2);
        }
        return "\n".join(lines);
    }
    
    public static string qualify(string f, string pardir = os.path.realpath(os.path.dirname(@__file__))) {
        // type: (Text, Text) -> Text
        return os.path.join(pardir, f);
    }
    
    public static void convert(
        object stem,
        object package_name,
        object output,
        object do_onnx_ml = false,
        object lite = false,
        object protoc_path = "") {
        object proto_base;
        // type: (Text, Text, Text, bool, bool, Text) -> None
        var proto_in = qualify("{}.in.proto".format(stem));
        var need_rename = package_name != DEFAULT_PACKAGE_NAME;
        // Having a separate variable for import_ml ensures that the import statements for the generated
        // proto files can be set separately from the ONNX_ML environment variable setting.
        var import_ml = do_onnx_ml;
        // We do not want to generate the onnx-data-ml.proto files for onnx-data.in.proto,
        // as there is no change between onnx-data.proto and the ML version.
        if (proto_in.Contains("onnx-data")) {
            do_onnx_ml = false;
        }
        if (do_onnx_ml) {
            proto_base = need_rename ? "{}_{}-ml".format(stem, package_name) : "{}-ml".format(stem);
        } else {
            proto_base = need_rename ? "{}_{}".format(stem, package_name) : "{}".format(stem);
        }
        var proto = qualify("{}.proto".format(proto_base), pardir: output);
        var proto3 = qualify("{}.proto3".format(proto_base), pardir: output);
        Console.WriteLine("Processing {}".format(proto_in));
        using (var fin = io.open(proto_in, "r")) {
            source = fin.read();
            Console.WriteLine("Writing {}".format(proto));
            using (var fout = io.open(proto, "w", newline: "")) {
                fout.write(autogen_header);
                fout.write(translate(source, proto: 2, onnx_ml: import_ml, package_name: package_name));
                if (lite) {
                    fout.write(LITE_OPTION);
                }
            }
            Console.WriteLine("Writing {}".format(proto3));
            using (var fout = io.open(proto3, "w", newline: "")) {
                fout.write(autogen_header);
                fout.write(translate(source, proto: 3, onnx_ml: import_ml, package_name: package_name));
                if (lite) {
                    fout.write(LITE_OPTION);
                }
            }
            if (protoc_path) {
                porto3_dir = os.path.dirname(proto3);
                base_dir = os.path.dirname(porto3_dir);
                gen_proto3_code(protoc_path, proto3, base_dir, base_dir, base_dir);
                pb3_files = glob.glob(os.path.join(porto3_dir, "*.proto3.*"));
                foreach (var pb3_file in pb3_files) {
                    Console.WriteLine("Removing {}".format(pb3_file));
                    os.remove(pb3_file);
                }
            }
            if (need_rename) {
                if (do_onnx_ml) {
                    proto_header = qualify("{}-ml.pb.h".format(stem), pardir: output);
                } else {
                    proto_header = qualify("{}.pb.h".format(stem), pardir: output);
                }
                Console.WriteLine("Writing {}".format(proto_header));
                using (var fout = io.open(proto_header, "w", newline: "")) {
                    fout.write("#pragma once\n");
                    fout.write("#include \"{}.pb.h\"\n".format(proto_base));
                }
            }
        }
        // Generate py mapping
        // "-" is invalid in python module name, replaces '-' with '_'
        var pb_py = qualify("{}_pb.py".format(stem.replace("-", "_")), pardir: output);
        if (need_rename) {
            var pb2_py = qualify("{}_pb2.py".format(proto_base.replace("-", "_")), pardir: output);
        } else if (do_onnx_ml) {
            pb2_py = qualify("{}_ml_pb2.py".format(stem.replace("-", "_")), pardir: output);
        } else {
            pb2_py = qualify("{}_pb2.py".format(stem.replace("-", "_")), pardir: output);
        }
        Console.WriteLine("generating {}".format(pb_py));
        using (var f = open(pb_py, "w")) {
            f.write(dedent(@"\
        # This file is generated by setup.py. DO NOT EDIT!

        from __future__ import absolute_import
        from __future__ import division
        from __future__ import print_function
        from __future__ import unicode_literals

        from .{} import *  # noqa
        ".format(os.path.splitext(os.path.basename(pb2_py))[0])).ToString());
        }
    }
    
    public static void main() {
        // type: () -> None
        var parser = argparse.ArgumentParser(description: "Generates .proto file variations from .in.proto");
        parser.add_argument("-p", "--package", @default: "onnx", help: "package name in the generated proto files (default: %(default)s)");
        parser.add_argument("-m", "--ml", action: "store_true", help: "ML mode");
        parser.add_argument("-l", "--lite", action: "store_true", help: "generate lite proto to use with protobuf-lite");
        parser.add_argument("-o", "--output", @default: os.path.realpath(os.path.dirname(@__file__)), help: "output directory (default: %(default)s)");
        parser.add_argument("--protoc_path", @default: "", help: "path to protoc for proto3 file validation");
        parser.add_argument("stems", nargs: "*", @default: new List<string> {
            "onnx",
            "onnx-operators",
            "onnx-data"
        }, help: "list of .in.proto file stems (default: %(default)s)");
        var args = parser.parse_args();
        if (!os.path.exists(args.output)) {
            os.makedirs(args.output);
        }
        foreach (var stem in args.stems) {
            convert(stem, package_name: args.package, output: args.output, do_onnx_ml: args.ml, lite: args.lite, protoc_path: args.protoc_path);
        }
    }
    
    static gen_proto() {
        main();
    }
}
